
import { Type, Modality } from "@google/genai";
import { GoogleGenAI } from "@google/genai";
import { Moment, AeternyStyle, AeternyVoice, UserTier, Language, Journey, StoryStyle } from '../types';
import { decode, decodeAudioData } from '../utils/audio';

// æternacy™ Neural Processing Service
// GLOBAL PRESET: Grounded Realism for Living Images
const LIVING_FRAME_PROTOCOL = `
STRICT ARCHIVAL PROTOCOL:
1. DO NOT change the perspective, composition, or camera angle of the provided image.
2. DO NOT add new scenes, characters, or objects.
3. DO NOT create dramatic pans or cinematic zooms.
4. ONLY animate existing elements realistically (e.g., gentle breathing, subtle hair movement in a soft breeze, natural eye blinks, minor light/shadow ripples).
5. THE GOAL is a "Living Photograph" that captures the exact moment as it naturally occurred, with zero extra effects.
`;

export interface SearchResult {
    id: number;
    reason: string;
}

const VOICE_MAP: Record<string, string> = {
    'Sarah': 'Kore',
    'David': 'Charon',
    'Emma': 'Zephyr',
    'James': 'Puck',
    'UserSignature': 'Kore', 
    'Masculine': 'Fenrir',
    'Feminine': 'Kore',
    'Neutral': 'Charon'
};

export async function imageUrlToPayload(url: string): Promise<{ data: string; mimeType: string }> {
    const response = await fetch(url);
    const blob = await response.blob();
    const base64 = await new Promise<string>((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve((reader.result as string).split(',')[1]);
        reader.readAsDataURL(blob);
    });
    return { data: base64, mimeType: blob.type };
}

export async function editImage(data: string, mimeType: string, prompt: string): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
            parts: [
                { inlineData: { data, mimeType } },
                { text: prompt }
            ]
        }
    });
    for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData) {
            return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
    }
    throw new Error("No image generated by the model.");
}

export async function generateVideo(prompt: string, imagePayload: { data: string; mimeType: string }, aspectRatio: '16:9' | '9:16' = '16:9'): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    // ENFORCING THE REALISM PROTOCOL PROJECT-WIDE
    const enhancedPrompt = `${LIVING_FRAME_PROTOCOL}\nUser Context: ${prompt}`;

    try {
        let operation = await ai.models.generateVideos({
            model: 'veo-3.1-fast-generate-preview',
            prompt: enhancedPrompt,
            image: {
                imageBytes: imagePayload.data,
                mimeType: imagePayload.mimeType
            },
            config: {
                numberOfVideos: 1,
                resolution: '720p',
                aspectRatio
            }
        });

        while (!operation.done) {
            await new Promise(resolve => setTimeout(resolve, 10000));
            operation = await ai.operations.getVideosOperation({ operation });
        }

        const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
        const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
        if (!response.ok) {
            const errBody = await response.json();
            throw new Error(errBody.error?.message || "PERMISSION_DENIED");
        }
        const blob = await response.blob();
        return URL.createObjectURL(blob);
    } catch (e: any) {
        const msg = e.message || "";
        if (msg.includes("403") || msg.includes("PERMISSION_DENIED") || msg.includes("Requested entity was not found")) {
             throw new Error("PERMISSION_DENIED: Institutional link required for manifestation.");
        }
        throw e;
    }
}

export async function getRelatedMoments(moment: Moment, allMoments: Moment[]): Promise<SearchResult[]> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const context = allMoments
        .filter(m => m.id !== moment.id)
        .map(m => ({ id: m.id, title: m.title, desc: m.description }));
    
    const prompt = `Given the target memory "${moment.title}: ${moment.description}", find relevant related memories from this collection: ${JSON.stringify(context)}. Return a JSON array of objects with "id" and "reason" fields.`;
    
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: prompt,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        id: { type: Type.NUMBER },
                        reason: { type: Type.STRING }
                    },
                    required: ["id", "reason"]
                }
            }
        }
    });
    return JSON.parse(response.text || "[]");
}

export async function createLegacyLetter(moments: Moment[]): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const context = moments.map(m => `${m.date}: ${m.title} - ${m.description}`).join('\n');
    const response = await ai.models.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `You are æterny, a personal biographer. Write a deeply heartfelt and moving legacy letter to future generations based on these life chapters:\n${context}`
    });
    return response.text || "";
}

export async function generateVideoScript(item: Moment | Journey, style: AeternyStyle): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const title = item.title;
    const desc = item.description;
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Write a short, evocative script (approx 50 words) for a cinematic video reflection based on this memory: "${title}: ${desc}". The tone should be ${style}. Respond only with the script text.`
    });
    return response.text || "";
}

export async function generateTitleSuggestions(mediaItems: { data: string; mimeType: string }[]): Promise<string[]> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const imageParts = mediaItems.map(item => ({ inlineData: { mimeType: item.mimeType, data: item.data } }));
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: {
            parts: [...imageParts, { text: "Suggest 3 evocative, short titles for this specific life story moment. Return a JSON array of strings only." } as any]
        },
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: { type: Type.STRING }
            }
        }
    });
    return JSON.parse(response.text || '[]');
}

export async function generateAeternyStory(
    mediaItems: { data: string; mimeType: string }[], 
    userContext: { name: string; familyMembers?: string[]; eventHint?: string; isShort?: boolean },
    language: Language = 'en',
    style: StoryStyle = 'nostalgic'
): Promise<{ title: string; story: string; tags: any }> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const model = 'gemini-3-pro-preview';
    
    const imageParts = mediaItems.map(item => ({
        inlineData: { mimeType: item.mimeType, data: item.data }
    }));

    const STYLE_PROMPTS: Record<StoryStyle, string> = {
        nostalgic: "Write in a warm, reflective tone. Use sensory details. Focus on emotions and lasting impressions.",
        poetic: "Use vivid imagery and metaphors. Short, impactful sentences. Focus on beauty and meaning.",
        journal: "Write as a detailed diary entry. Include specific observations. Factual but personal.",
        lighthearted: "Write with humor and warmth. Use conversational language. Include funny details."
    };

    const styleInstruction = STYLE_PROMPTS[style];
    const lengthConstraint = userContext.isShort 
        ? "Keep the story ULTRA-SHORT (max 40 words). Write exactly 1 or 2 powerful sentences only."
        : "Keep the story concise and evocative (approx 100-150 words). Write max 1-2 paragraphs.";

    const prompt = `
        You are æterny, a warm and nostalgic personal biographer. 
        Analyze these photos and synthesize them into a single coherent life story moment.
        
        USER CONTEXT:
        Name: ${userContext.name}
        Event Hint: ${userContext.eventHint || 'Unknown'}
        
        STORYTELLING STYLE:
        ${styleInstruction}
        
        ${lengthConstraint}
        
        Write strictly in the FIRST-PERSON. Return JSON.
    `;

    const response = await ai.models.generateContent({
        model,
        contents: { parts: [...imageParts, { text: prompt } as any] },
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    title: { type: Type.STRING },
                    story: { type: Type.STRING },
                    tags: {
                        type: Type.OBJECT,
                        properties: {
                            location: { type: Type.ARRAY, items: { type: Type.STRING } },
                            people: { type: Type.ARRAY, items: { type: Type.STRING } },
                            activities: { type: Type.ARRAY, items: { type: Type.STRING } },
                            emotion: { type: Type.STRING }
                        }
                    }
                },
                required: ["title", "story", "tags"]
            }
        }
    });

    return JSON.parse(response.text || "{}");
}

export async function mergeMomentsIntoJourney(
    moments: Moment[],
    userName: string,
    journeyTitle: string
): Promise<{ title: string; story: string }> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const model = 'gemini-3-pro-preview';
    
    const context = moments.map(m => `
        Title: ${m.title}
        Date: ${m.date}
        Story: ${m.description}
        Tags: ${[...(m.people || []), ...(m.activities || []), m.location || ''].join(', ')}
    `).join('\n---\n');

    const prompt = `
        You are æterny, the master biographer. 
        Synthesize the following collection of memories into a single, expansive "Journæy".
        
        The user wants to call this journey: "${journeyTitle}".
        
        MOMENT DATA:
        ${context}
        
        GOAL:
        1. Create a seamless, high-end narrative that flows through all these moments.
        2. Focus on the emotional arc and personal growth of ${userName}.
        3. Maintain a sophisticated, cinematic, and first-person perspective.
        4. Do not just list the events; weave them together as if reflecting on a major chapter of life.
        5. Length: Approx 200-250 words.
        
        Return JSON: {"title": "The Refined Title", "story": "The full woven narrative"}
    `;

    const response = await ai.models.generateContent({
        model,
        contents: prompt,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    title: { type: Type.STRING },
                    story: { type: Type.STRING }
                },
                required: ["title", "story"]
            }
        }
    });

    let rawJson = response.text || "{}";
    if (rawJson.includes('```json')) {
        rawJson = rawJson.split('```json')[1].split('```')[0].trim();
    } else if (rawJson.includes('```')) {
        rawJson = rawJson.split('```')[1].split('```')[0].trim();
    }

    return JSON.parse(rawJson);
}

export async function textToSpeech(text: string, ctx: AudioContext, voice: string): Promise<AudioBuffer | null> {
    if (!text || text.trim().length < 2) return null;
    
    try {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const targetVoice = VOICE_MAP[voice] || 'Kore';
        
        if (ctx.state === 'suspended') await ctx.resume();

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-preview-tts',
            contents: [{ parts: [{ text }] }],
            config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: targetVoice } } }
            }
        });

        const part = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
        if (!part?.inlineData?.data) {
            return null;
        }

        return await decodeAudioData(decode(part.inlineData.data), ctx, 24000, 1);
    } catch (err: any) {
        console.error("TTS Engine failure", err);
        return null;
    }
}

export async function rewriteStory(originalStory: string, prompt: string): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: `Original Story: ${originalStory}\n\nRequest: ${prompt}. Rewrite with the same persona and voice.`
    });
    return response.text || originalStory;
}

export async function semanticSearch(query: string, moments: Moment[]): Promise<SearchResult[]> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const manifest = moments.map(m => ({ id: m.id, title: m.title, desc: m.description.substring(0, 100) }));
    const prompt = `Search the archive for: "${query}". Return top matches as JSON array: [{"id": number, "reason": "string"}]`;
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: prompt,
        config: { 
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: { id: { type: Type.NUMBER }, reason: { type: Type.STRING } },
                    required: ["id", "reason"]
                }
            }
        }
    });
    return JSON.parse(response.text || "[]");
}

export async function startGenericAeternyChat(style: any, tier: any) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const chat = ai.chats.create({ 
        model: 'gemini-3-pro-preview',
        config: {
            systemInstruction: "You are æterny, a warm and deeply empathic personal curator. Your goal is to guide the user through their life memories, helping them find meaning and beauty. You listen more than you speak, and when you do speak, it's with wisdom and genuine interest."
        }
    });
    const resp = await chat.sendMessage({ message: "Initialize empathic session." });
    return { chat, initialMessage: resp.text };
}

export async function continueAeternyChat(chat: any, message: string) {
    const resp = await chat.sendMessage({ message });
    return resp.text || "";
}

export async function createAeternyAgent(name: string, context: string, lang: string) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    return ai.chats.create({
        model: 'gemini-3-pro-preview',
        config: { systemInstruction: `Persona: æterny. User: ${name}. Context: ${context}.` }
    });
}

export async function neuralMapSearch(query: string, lat?: number, lng?: number) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: query,
        config: { tools: [{ googleSearch: {} }, { googleMaps: {} }] }
    });
    return { text: response.text || "", sources: [] };
}

export async function generateStylePreviews(mediaItems: { data: string; mimeType: string }[], userContext: any) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const imageParts = mediaItems.map(item => ({ inlineData: { mimeType: item.mimeType, data: item.data } }));
    const prompt = `Generate short 1-sentence previews for these photos in 4 styles: nostalgic, poetic, journal, lighthearted. Return JSON.`;
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: { parts: [...imageParts, { text: prompt } as any] },
        config: { responseMimeType: "application/json" }
    });
    return JSON.parse(response.text || "{}");
}

export async function createDemoStoryFromImages(
    mediaItems: { data: string; mimeType: string }[], 
    userName: string = "User",
    style: StoryStyle = 'nostalgic',
    isShort: boolean = false
): Promise<{ title: string; story: string; tags: any }> {
    return generateAeternyStory(mediaItems, { name: userName || "User", isShort }, 'en', style);
}

export async function checkImageSafety(data: string, mimeType: string): Promise<boolean> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: {
            parts: [
                { inlineData: { data, mimeType } },
                { text: "Is this image appropriate for a family history archive? Respond only with 'TRUE' if safe or 'FALSE' if inappropriate." }
            ]
        }
    });
    const text = response.text?.trim().toUpperCase();
    return text === 'TRUE' || text?.includes('TRUE');
}

export async function mergeJourneysIntoEpoch(
    journeys: Journey[],
    userName: string,
    epochTitle: string
): Promise<{ title: string; description: string; theme: string }> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const context = journeys.map(j => `Title: ${j.title}\nDescription: ${j.description}`).join('\n---\n');
    const prompt = `Synthesize these journeys into a single 'Epoch' titled '${epochTitle}' for user ${userName}. Identify the core theme and provide an expansive description.`;

    const response = await ai.models.generateContent({
        model: 'gemini-3-pro-preview',
        contents: prompt,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    title: { type: Type.STRING },
                    description: { type: Type.STRING },
                    theme: { type: Type.STRING }
                },
                required: ["title", "description", "theme"]
            }
        }
    });
    return JSON.parse(response.text || "{}");
}
